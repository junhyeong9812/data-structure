# 10. LRU ìºì‹œ (Least Recently Used Cache)

## ğŸ“‹ ë¬¸ì œ ì •ì˜

**ê°€ì¥ ìµœê·¼ì— ì‚¬ìš©ë˜ì§€ ì•Šì€ í•­ëª©**ì„ ë¨¼ì € ì œê±°í•˜ëŠ” ìºì‹œë¥¼ êµ¬í˜„í•˜ì„¸ìš”.

LRU ìºì‹œëŠ” ì œí•œëœ ìš©ëŸ‰ ë‚´ì—ì„œ ë°ì´í„°ë¥¼ ìºì‹±í•˜ë©°, ìš©ëŸ‰ì´ ê°€ë“ ì°¼ì„ ë•Œ
ê°€ì¥ ì˜¤ë˜ ì „ì— ì‚¬ìš©ëœ í•­ëª©ì„ ì œê±°í•©ë‹ˆë‹¤.

---

## ğŸ¯ í•™ìŠµ ëª©í‘œ

- í•´ì‹œë§µê³¼ ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ì˜ ì¡°í•©
- O(1) ì‹œê°„ ë³µì¡ë„ì˜ get/put êµ¬í˜„
- ìºì‹œ êµì²´ ì •ì±… ì´í•´
- ì‹¤ë¬´ì—ì„œì˜ ìºì‹œ í™œìš©

---

## ğŸ“ ìš”êµ¬ì‚¬í•­

### ê¸°ë³¸ ì—°ì‚°

| ë©”ì„œë“œ | ì„¤ëª… | ì‹œê°„ë³µì¡ë„ |
|--------|------|-----------|
| `get(key)` | í‚¤ì— í•´ë‹¹í•˜ëŠ” ê°’ ë°˜í™˜, ì—†ìœ¼ë©´ -1 (ë˜ëŠ” null) | O(1) |
| `put(key, value)` | í‚¤-ê°’ ìŒ ì €ì¥, ì´ë¯¸ ìˆìœ¼ë©´ ì—…ë°ì´íŠ¸ | O(1) |
| `remove(key)` | í‚¤ì— í•´ë‹¹í•˜ëŠ” í•­ëª© ì œê±° | O(1) |
| `size()` | í˜„ì¬ ì €ì¥ëœ í•­ëª© ê°œìˆ˜ | O(1) |
| `capacity()` | ìµœëŒ€ ìš©ëŸ‰ | O(1) |
| `clear()` | ëª¨ë“  í•­ëª© ì œê±° | O(1) |

### ë™ì‘ ê·œì¹™

1. **get(key)**: í‚¤ê°€ ì¡´ì¬í•˜ë©´ í•´ë‹¹ í•­ëª©ì„ **ê°€ì¥ ìµœê·¼ ì‚¬ìš©**ìœ¼ë¡œ í‘œì‹œ
2. **put(key, value)**: 
   - í‚¤ê°€ ì´ë¯¸ ì¡´ì¬í•˜ë©´ ê°’ ì—…ë°ì´íŠ¸ + ìµœê·¼ ì‚¬ìš©ìœ¼ë¡œ í‘œì‹œ
   - ìƒˆ í‚¤ì´ê³  ìš©ëŸ‰ì´ ê°€ë“ ì°¼ìœ¼ë©´ **LRU í•­ëª© ì œê±°** í›„ ì‚½ì…
3. ìš©ëŸ‰ì€ ìƒì„± ì‹œ ê³ ì •

### ì¶”ê°€ ê¸°ëŠ¥ (ì„ íƒ)

| ë©”ì„œë“œ | ì„¤ëª… |
|--------|------|
| `peek(key)` | ê°’ ì¡°íšŒë§Œ (ì‚¬ìš© ê¸°ë¡ ê°±ì‹  ì•ˆ í•¨) |
| `containsKey(key)` | í‚¤ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ |
| `getOldest()` | ê°€ì¥ ì˜¤ë˜ëœ í•­ëª© ì¡°íšŒ |
| `getNewest()` | ê°€ì¥ ìµœê·¼ í•­ëª© ì¡°íšŒ |
| `keys()` | ëª¨ë“  í‚¤ ë°˜í™˜ (ìµœê·¼ ìˆœì„œ) |
| `values()` | ëª¨ë“  ê°’ ë°˜í™˜ (ìµœê·¼ ìˆœì„œ) |

---

## ğŸ“Š ì…ì¶œë ¥ ì˜ˆì‹œ

### ì˜ˆì œ 1: ê¸°ë³¸ ì‚¬ìš©
```java
LRUCache cache = new LRUCache(3);  // ìš©ëŸ‰ 3

cache.put(1, 100);
cache.put(2, 200);
cache.put(3, 300);
// í˜„ì¬ ìƒíƒœ: [1, 2, 3] (1ì´ ê°€ì¥ ì˜¤ë˜ë¨)

cache.get(1);  // 100 ë°˜í™˜, 1ì„ ìµœê·¼ìœ¼ë¡œ ì´ë™
// í˜„ì¬ ìƒíƒœ: [2, 3, 1] (2ê°€ ê°€ì¥ ì˜¤ë˜ë¨)

cache.put(4, 400);  // ìš©ëŸ‰ ì´ˆê³¼! ê°€ì¥ ì˜¤ë˜ëœ 2 ì œê±°
// í˜„ì¬ ìƒíƒœ: [3, 1, 4]

cache.get(2);  // -1 ë°˜í™˜ (ì œê±°ë¨)
cache.get(3);  // 300 ë°˜í™˜
```

### ì˜ˆì œ 2: ê°’ ì—…ë°ì´íŠ¸
```java
LRUCache cache = new LRUCache(2);

cache.put(1, 100);
cache.put(2, 200);
// ìƒíƒœ: [1, 2]

cache.put(1, 111);  // ê¸°ì¡´ í‚¤ ì—…ë°ì´íŠ¸ + ìµœê·¼ìœ¼ë¡œ ì´ë™
// ìƒíƒœ: [2, 1]

cache.put(3, 300);  // ìš©ëŸ‰ ì´ˆê³¼, 2 ì œê±°
// ìƒíƒœ: [1, 3]

cache.get(1);  // 111 ë°˜í™˜ (ì—…ë°ì´íŠ¸ëœ ê°’)
cache.get(2);  // -1 ë°˜í™˜ (ì œê±°ë¨)
```

### ì˜ˆì œ 3: ì œë„¤ë¦­ ë²„ì „
```java
LRUCache<String, User> userCache = new LRUCache<>(100);

userCache.put("user:123", new User("Alice"));
userCache.put("user:456", new User("Bob"));

User alice = userCache.get("user:123");  // User ê°ì²´ ë°˜í™˜
User unknown = userCache.get("user:999");  // null ë°˜í™˜
```

---

## ğŸ” ì œì•½ ì¡°ê±´

- ìš©ëŸ‰ì€ 1 ì´ìƒ
- í‚¤ëŠ” null í—ˆìš©í•˜ì§€ ì•ŠìŒ (êµ¬í˜„ì— ë”°ë¼)
- ê°’ì€ null í—ˆìš© ê°€ëŠ¥ (êµ¬í˜„ì— ë”°ë¼)
- ëª¨ë“  ì—°ì‚°ì€ O(1) ì‹œê°„ ë³µì¡ë„

---

## ğŸ’¡ íŒíŠ¸

### ìë£Œêµ¬ì¡° ì¡°í•©
```
í•´ì‹œë§µ (HashMap): key â†’ Node ë¹ ë¥¸ ì¡°íšŒ
ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ (Doubly Linked List): ìˆœì„œ ê´€ë¦¬, O(1) ì´ë™/ì‚­ì œ

    HashMap
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”
    â”‚ 1 â†’ â—â”€â”¼â”€â”€â†’ [Node: key=1, val=100]
    â”‚ 2 â†’ â—â”€â”¼â”€â”€â†’ [Node: key=2, val=200]
    â”‚ 3 â†’ â—â”€â”¼â”€â”€â†’ [Node: key=3, val=300]
    â””â”€â”€â”€â”€â”€â”€â”€â”˜
    
    ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ (head = ìµœê·¼, tail = ì˜¤ë˜ë¨)
    
    head â†â†’ [1,100] â†â†’ [2,200] â†â†’ [3,300] â†â†’ tail
    (newest)                              (oldest/LRU)
```

### ë…¸ë“œ êµ¬ì¡°
```java
class Node {
    int key, value;
    Node prev, next;
}
```

### í•µì‹¬ ì—°ì‚°
```java
// ë…¸ë“œë¥¼ ë§¨ ì•(head)ìœ¼ë¡œ ì´ë™
void moveToHead(Node node) {
    removeNode(node);
    addToHead(node);
}

// ë…¸ë“œ ì œê±° (O(1))
void removeNode(Node node) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
}

// ë§¨ ì•ì— ì¶”ê°€ (O(1))
void addToHead(Node node) {
    node.next = head.next;
    node.prev = head;
    head.next.prev = node;
    head.next = node;
}

// LRU í•­ëª© ì œê±° (tail ë°”ë¡œ ì•)
Node removeTail() {
    Node lru = tail.prev;
    removeNode(lru);
    return lru;
}
```

---

## âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] ê¸°ë³¸ get, put êµ¬í˜„ (O(1))
- [ ] ìš©ëŸ‰ ì´ˆê³¼ ì‹œ LRU ì œê±°
- [ ] ê°’ ì—…ë°ì´íŠ¸ ì‹œ ìµœê·¼ ì‚¬ìš©ìœ¼ë¡œ ì´ë™
- [ ] ë”ë¯¸ head/tailë¡œ ì—£ì§€ ì¼€ì´ìŠ¤ ì²˜ë¦¬
- [ ] ì œë„¤ë¦­ ë²„ì „ êµ¬í˜„
- [ ] Thread-safe ë²„ì „ (ì„ íƒ)

---

## ğŸ“š ì°¸ê³ 

- [LeetCode 146. LRU Cache](https://leetcode.com/problems/lru-cache/)
- Javaì˜ `LinkedHashMap`ì˜ `removeEldestEntry()`
- Redisì˜ maxmemory-policy
- CPU ìºì‹œì˜ LRU ì •ì±…
